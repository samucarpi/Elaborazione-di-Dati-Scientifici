function rm = replacevars(r,vars,data)
%REPLACEVARS Replaces variables based on factor-based models.
%  This function generates a matrix (or matrices) that can be used to
%  replace "bad" variables from data matrices with the values that are most
%  consistent with a given factor-based model (PCA, PLS, PCR, CLS, MCR,
%  etc.)
%  The outputs of this function are dependent on the inputs provided. If
%  you provide a model and a list of variables to replace, the function
%  returns the matrix or matrices required to do the mathematical
%  replacement operation. If you also provide data on which to operate, the
%  function returns the data with the replacements performed for you.
%
% INPUTS:
%  model = can be one of the following:
%          (1) a model structure generated by the PCA or PLS functions or
%               the Anlysis GUI
%          (2) a set of loadings (column) vectors
%          (3) the residuals generating matrix I-PP'
%          (4) a PLS model like the ones generated by the function PLSRSGN
%              or PLSRSGCV.
%   vars   = an optional row vector containing the column indices of the
%             variables to be replaced. 
%   rmtype = an optional string indicating the type of replacement matrix
%             to output (only valid when next output is omitted).
%              'matrix' = returns an entire rm matrix
%              'loads'  = returns the pseudo-inverse of the loadings.
%             See below for details on these outputs. Default is 'loads'.
%   data   = a matrix or DataSet Object in which the specified variables
%             are to be replaced. If (vars) is omitted, (data) is searched
%             for non-finite values (NaN or Inf) and these are replaced.
%             When data is supplied, only the replaced data is returned
%             (repdata).
%
% OUTPUTS:
%  repdata = The data with the chosen variables replaced.
%       rm = This output can be used with data to replace the variables
%             indicated by (vars) with the values which are most consistent
%             with the given model. This output is only available when
%             (data) is not provided.
%            If input (rmtype) is not provided or is 'loads', then rm will
%             be a structure containing three matrices which can be used to
%             replace varibles using:
%               data(:,rm.vars) = data * rm.ploads * rm.loads
%            If (rmtype) is 'matrix' then rm will be a matrix which can be
%             used to replace variables using:
%               data = data * rm
%            The 'matrix' form of rm will nearly always require a
%             significantly larger amount of memory, but can be applied
%             easier.
%
%I/O: repdata = replacevars(model,vars,data);
%I/O: repdata = replacevars(model,data);
%I/O:      rm = replacevars(model,vars);
%I/O:      rm = replacevars(model,vars,rmtype);
%
%See also: EXCLUDEMISSING, MATCHVARS, MDCHECK, PCA, PLSRSGCV, PLSRSGN

% Copyright © Eigenvector Research, Inc. 1991
% Licensee shall not re-compile, translate or convert "M-files" contained
%  in PLS_Toolbox for use with any software other than MATLAB®, without
%  written permission from Eigenvector Research, Inc.
%nbg 11/00 removed missdat from see also
%bmw 8/02 added support for PCA models and dataset objects
%jms 10/02 added PLS model support
%jms 10/04 fixed bug using unique on uint8 data in Matlab 6.1 (R12)

if nargin == 0; r = 'io'; end
varargin{1} = r;
if ischar(varargin{1});
  options = [];
  if nargout==0; clear rm; evriio(mfilename,varargin{1},options); else; rm = evriio(mfilename,varargin{1},options); end
  return; 
end

%sort out input variables and define output type
rmtype = 'loads'; %default rmtype
switch nargin
  case 2
    if ~isempty(vars) & (min(size(vars))>1 | isa(vars,'dataset') | mdcheck(vars) )
      % (model,data)
      data = vars;
      vars = [];
    else
      % (model,vars)
      data = [];
    end
  case 3
    if ischar(data)
      % (model,vars,rmtype)
      rmtype = data;
      data   = [];
    else
      % (model,vars,data)
      %do nothing... we're set
    end
  otherwise
    error('Unrecognized input format');
end

%handle inputs with data as input
if ~isempty(data) & isempty(vars)
  % No VARS was given - identify which variables are missing in "data" and
  % do recursive calls to replace to fill in those values. We try
  % replacement at least twice to compare results. When the maximum
  % difference between replaced values is reduced to 0.01% of the value
  % itself, we stop.
  
  if isa(data,'dataset')
    wasdso = true;
    origincl = data.include;
  else
    wasdso = false;
    data = dataset(data);
  end
  model = r;
  
  %get list of included variables if a model structure
  if ismodel(model)
    notusedinmodel = setdiff(1:size(data,2),model.detail.includ{2});
  else
    notusedinmodel = [];   %everything is fair game if not a model structure
  end
  
  [flag,missmap]            = mdcheck(data);
  missmap(:,notusedinmodel) = 0;   %ignore missing values in columns that weren't used in the model

  if checkmlversion('<','6.5');  %Version 6.1 - convert to double before doing unique 
    %(unique doesn't work on uint8 when 2nd and 3rd outputs are requested)
    [ptrns,junk,group]        = unique(logical(double(missmap)),'rows');
  else    
    [ptrns,junk,group]        = unique(missmap,'rows');
  end

  %loop through each unique missing pattern of variables
  for i=1:size(ptrns,1);  
    use  = find(group==i);        %these rows have similar missing variables, replace them together
    mind = find(ptrns(i,:));

    if ~isempty(mind);
      data.data(use,mind) = 0;           %substitute in finite values for infinite (missing) values to start loop
      data.include{1} = use;
      g = 1;   %start loop
      iterations = 0;
      while g>.01 & iterations < 20;   %stop loop when maximum change is < .01%
        % temporarily set data.include{1} = use; to avoid it being reset
        repdata        = replacevars(model,mind,data(use,:));      %get approximation
        g              = abs((data.data(use,mind)-repdata.data(:,mind))./(abs(repdata.data(:,mind))+eps))*100;   %calcuate amount of change from last estimation
        g              = max(max(g));        %maximum change in any replaced value
        data.data(use,mind) = repdata.data(:,mind);    %insert replaced values
        iterations     = iterations + 1;     %increment # of cycles
      end
    end
  end
  
  if wasdso
    data.include{1} = origincl{1};
    rm = data;
  else
    rm = data.data;
  end
  
  return
end

%We get down here ONLY if vars was defined in the inputs.
%Calculate the replacement matrices for the indicated variables
repdata = [];
if ismodel(r)
  if ismember(lower(r.modeltype),{'pca','pls','pcr','plsda','mcr','cls','lwr','svmda', 'svm', 'ann'})
    if ismember(lower(r.modeltype),{'svmda', 'svm', 'ann'})
      % must be compression model. Look for model
      if ~isempty(r.detail.compressionmodel)
        r = r.detail.compressionmodel;
      else
        error('X-block data has missing values. Please use X-block compression since this allows in-filling of missing values.')
      end
    end
    rmod = r; %to save for later
    rinc = r.detail.includ{2};
    switch lower(r.modeltype)
      case 'pls'
        r = r.wts;
      case {'mcr' 'cls'}
        r = pinv(r.loads{2,1})';
      otherwise
        r = r.loads{2};
    end
    nvars = zeros(size(vars));
    for i = 1:length(vars)
      inds = find(rinc == vars(i));
      if isempty(inds)
        error(sprintf('Variable %g was not used in model',vars(i)))
      else
        nvars(i) = inds;
      end
    end
    vars = nvars;
    if ~isempty(data)
      repdata = data;
      if ~isa(data,'dataset')
        data = dataset(data);
      end
      [m,n] = size(data.data);
      if rmod.datasource{1}.size(2) ~= n
        error('Model requires a different number of variables than provided in data')
      end
      data.includ{2} = rinc;
    end
  else
    error(['Unable to replace missing/excluded data for ' r.modeltype ' models.'])
  end
elseif isa(r,'double')
  rmod = [];
  if ~isempty(data);
    repdata = data;
    if isa(data,'dataset')
      data = data.data;
    end
    [m,n] = size(data);
    [ml,nl] = size(r);
    if n ~= ml
      error('Model size does not match data size')
    end
  end
end

[mr,nr] = size(r);
[mv,nv] = size(vars);
vars = sort(vars);
%  Check to see that information in vars is consistent with r
if max(vars) > mr
  error('Variable number specified is > total number of variables')
elseif min(vars) <= 0.0
  error('Variable number can not be negative')
end
for i = 1:nv-1
  if vars(1,i) == vars(1,i+1)
    error('Each variabe must only be specified once')
  end
end
dif = vars - round(vars);
for i = 1:nv
  if dif(1,i) ~= 0.0
    error('Variable indices must be integers')
  end
end

if ~strcmp(rmtype,'matrix')   %default: use non-multipled method (fewer memory issues)

  use = setdiff(1:size(r,1),vars);
  temp = r*0;  %full-size loadings with all zeros
  temp(use,:) = pinv(r(use,:)');  %insert pseudo-inverse of loadings with ONLY the used variables

  %store everything in rm to apply later
  rm = [];
  rm.ploads = temp;
  rm.loads  = r(vars,:)';
  rm.vars   = vars;
  
else
  %use the more-memory-intensive "full matrix" method (allows easy
  %application, but takes a LOT of memory)
  
  %  Check for model type--if PCA loadings convert to I-PP' form
  if mr ~= nr
    try
      temp = eye(mr);
    catch
      error('Unable to create appropriately sized matrix. Try using rmtype ''loadings''.');
    end
    %(split up this calculation to reduce memory usage)
    temp = temp - r*r';
    r = temp;
    clear temp
  end
  %  Extract the r11 matrix from r using vars
  r11 = zeros(nv);
  for i = 1:nv
    for j = 1:nv
      r11(i,j) = r(vars(1,i),vars(1,j));
    end
  end
  %  Extract the r12 and r21 matrix from r using vars
  for k = 1:2
    temp = zeros(nv,mr);
    for i = 1:nv
      temp(i,:) = r(vars(1,i),:);
    end
    c = 0;
    for i = 1:nv
      temp(:,vars(1,i)-c:mr-1) = temp(:,(vars(1,i)+1-c):mr);
      c = c+1;
    end
    if k == 1
      r12 = temp(:,1:mr-nv);
      r = r';
    else
      r21 = temp(:,1:mr-nv);
    end
  end
  %  Calculate the regression matrix rr
  rave = (r12+r21)./2;
  rr = -rave'*inv(r11);
  %  Map rr into the replacement matrix rm
  rm = eye(mr);
  temp = [rr; zeros(nv)];
  for i = 1:nv
    temp(vars(1,i)+1:mr,:) = temp(vars(1,i):mr-1,:);
  end
  for i = 1:nv
    temp(vars(1,i),:) = zeros(1,nv);
  end
  for i = 1:nv
    rm(:,vars(1,i)) = temp(:,i);
  end

end

if ~isempty(data)
  if ~isempty(rmod)
    %model structure supplied, use preprocessing and impute data
    [data,ppa] = preprocess('apply',rmod.detail.preprocessing{1},data);
    data.data(:,data.includ{2}) = apply(data.data(:,data.includ{2}),rm);
    data       = preprocess('undo',ppa,data);
    
    if ~isa(repdata,'dataset')
      repdata(:,data.includ{2}(vars)) = data.data(:,data.includ{2}(vars));
    else
      repdata.data(:,data.includ{2}(vars)) = data.data(:,data.includ{2}(vars));
    end
  else
    %no model passed, replace the data in a standard matrix
    data = apply(data,rm);  
    if ~isdataset(repdata);
      repdata(:,vars) = data(:,vars);
    else
      repdata.data(:,vars) = data(:,vars);
    end
  end
    rm = repdata;
end

%----------------------------------------------------
function out = apply(in,rm);
% Generic apply function for rm

if ~isstruct(rm);
  %standard matrix, just project
  out = in*rm;
else
  %structure with critical items
  out = in;
  out(:,rm.vars) = in*rm.ploads*rm.loads;
end
